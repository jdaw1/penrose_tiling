%!PS

/DataAsOf (D:20250421143557) def
/Licence (GNU General Public License, Version 3, 29 June 2007) def
/URL (https://githubcom/jdaw1/penrose_tiling/) def
/Author (Julian D A Wiseman of wwwjdawisemancom) def
/TilingId 0 def
/NumFats 2 def
/NumThins 1 def
/EdgeLength 3.2360679774997898E+00 def

/XMin -3.23606797749979 def
/XMax 2 def
/YMin -3.077683537175254 def
/YMax 3.077683537175254 def

/ToPaint_XMin -4 def  % User changeable
/ToPaint_XMax +2 def
/ToPaint_YMin -4 def
/ToPaint_YMax +4 def

/R 1.618033988749895 def

/LongestPathToBeFilled 215 def  % User alterable If being increased, might need to add more colours to PaintPath




/PageWidth  297 360 mul 127 div def  % A3, long side.  User alterable: for US Tabloid use "11 72 mul".
/PageHeight 420 360 mul 127 div def  % A3, short side.  User alterable: for US Tabloid use "17 72 mul".
/OnPageTileCentreX PageWidth  0.5 mul def  % User alterable. This has tiling positioned wrt centre of paper page.
/OnPageTileCentreY PageHeight 0.5 mul def  % User alterable. This has tiling positioned wrt centre of paper page.
/Margin 18 def  % 18pt = 0.25" = 6.35mm. Enlarge if the printer can't work so close to the edge. Used only for default value of scale.

/Actual_XMin  XMin ToPaint_XMin  2 copy lt {exch} if pop  def
/Actual_YMin  YMin ToPaint_YMin  2 copy lt {exch} if pop  def
/Actual_XMax  XMax ToPaint_XMax  2 copy gt {exch} if pop  def
/Actual_YMax  YMax ToPaint_YMax  2 copy gt {exch} if pop  def
/ScaleFactor
	PageWidth  Margin 2 mul sub  Actual_XMax Actual_XMin sub  div  % Tight-fiting x.
	PageHeight Margin 2 mul sub  Actual_YMax Actual_YMin sub  div  % Tight-fiting y.
	2 copy gt {exch} if pop  % Lesser of them.
	% pop 150  % For endpapers, on A3, with TilingId=9,  perhaps choose X -3.4 to 2.4,  Y -4 to 4,  then scaling of 150. But YMMV.
def  % /ScaleFactor. User alterable. Could be of form "6 EdgeLength div", making an edge be 6pt on the paper.

% Expands box to match whole page (which might have different aspect ratio to original ToPaint_ choices). If unwanted, delete next four lines.
/Actual_XMin            OnPageTileCentreX neg ScaleFactor div  Actual_XMin Actual_XMax add 2 div add
/Actual_XMax PageWidth  OnPageTileCentreX sub ScaleFactor div  Actual_XMin Actual_XMax add 2 div add  def def
/Actual_YMin            OnPageTileCentreY neg ScaleFactor div  Actual_YMin Actual_YMax add 2 div add
/Actual_YMax PageHeight OnPageTileCentreY sub ScaleFactor div  Actual_YMin Actual_YMax add 2 div add  def def

<< /PageSize [PageWidth PageHeight] >> setpagedevice
/PaperMatrix matrix currentmatrix def
OnPageTileCentreX OnPageTileCentreY translate   ScaleFactor dup scale
Actual_XMax Actual_XMin add -2 div  Actual_YMax Actual_YMin add -2 div  translate  % User alterable. Optional specification of which point in tiling is to be in the specifed point of page.
% 0 rotate  % User alterable. Optional rotation, angle in degrees, positive rotating image anti-clockise. By default commented out.
/TileMatrix matrix currentmatrix def

/StrokeMulti  % User changable. Allows multi-layer strokes, such as black outer and white inner.
{
	//TileMatrix setmatrix   1 setlinejoin  [] 0 setdash
	[
		% {gsave  0 setgray  0 setlinecap  EdgeLength 20 div setlinewidth  stroke  grestore}  % #gsave ... grestore for each stroke, except the last. At finish path should be empty.
		% {       1 setgray  1 setlinecap  EdgeLength 60 div setlinewidth  stroke          }  % This pair paints thick black, then thin inner white. If uncommented, delete next line.
		{0 setgray  1 setlinecap  EdgeLength 30 div setlinewidth  stroke}  % Thin black only.
	] {exec} forall
} bind def  % StrokeMulti

mark
	/CreationDate (D:20250421143557)
	/Title (Penrose tiling)
	/Author (Julian D. A. Wiseman)
	/Subject (http://github.com/jdaw1/penrose_tiling/)
	/Keywords (Penrose tiling arcs)
	/Creator (C and PostScript coded by Julian D. A. Wiseman of www.jdawiseman.com/author.html)
/DOCINFO pdfmark

% Functions taken from https://github.com/jdaw1/placemat/blob/main/PostScript/placemat.ps
/ToString
{
	1 dict begin  dup type cvlit /Type exch def
	1 {
		Type /integertype  eq {11 string cvs exit ( ) Concatenate} if
		Type /realtype     eq {16 string cvs exit ( ) Concatenate} if
		Type /nametype     eq {dup length string cvs exit} if
		Type /stringtype   eq {exit} if
		Type /booleantype  eq {5 string cvs exit} if
		Type /operatortype eq {127 string cvs exit} if
		Type /marktype     eq {pop (mark) exit} if
		Type /nulltype     eq {pop (null) exit} if
		pop (-- not handled --)  % fall-back
	} repeat  end
} bind def  % /ToString

/Concatenate {2 copy length exch length dup 3 1 roll add string dup dup 5 3 roll exch putinterval 3 -1 roll 0 exch putinterval} bind def

% mark string|number|other ... string|number|other  ConcatenateToMark  string
/ConcatenateToMark
{
	4 dict begin
	counttomark /ctm exch def  /n 0 def
	ctm {ToString  dup length n add /n exch def  ctm 1 roll} repeat
	/p 0 def  /s n 65535 2 copy gt {exch} if pop string def
	ctm  -1  0
	{
		dup 0 gt
		{
			-1 roll   dup length p add  65532 le
				{s exch p exch dup length p add /p exch def putinterval}
				{s exch p exch 0 65532 p sub getinterval putinterval  s 65532 (...) putinterval  cleartomark  s  exit}
			ifelse  % too long
		} {pop pop s} ifelse
	} for
	end
} bind def  % /ConcatenateToMark

() =
/NumRhombii NumFats NumThins add def
[/TilingId /DataAsOf /NumFats /NumThins /NumRhombii /EdgeLength  /XMin /XMax /YMin /YMax  /ToPaint_XMin /ToPaint_XMax /ToPaint_YMin /ToPaint_YMax]
{
	dup 12 string cvs ( = ) Concatenate  exch load
	dup type /stringtype eq {(") exch (") Concatenate Concatenate} {16 string cvs} ifelse
	Concatenate =
} forall
mark (\nPageWidth = ) PageWidth  (pt = ) PageWidth 72 div  (" = ) PageWidth  127 mul 360 div (mm) ConcatenateToMark =
mark   (PageHeight = ) PageHeight (pt = ) PageHeight 72 div (" = ) PageHeight 127 mul 360 div (mm) ConcatenateToMark =
mark (T, B, L, and R margins each = ) Margin (pt = ) Margin 72 div (" = ) Margin 127 mul 360 div (mm) ConcatenateToMark =
mark (ScaleFactor = ) ScaleFactor ConcatenateToMark =
mark (On paper, length of an edge is ) EdgeLength ScaleFactor mul (pt = ) 1 index 72 div (" = 1"/) 1 2 index div ( = ) 5 index 127 mul 360 div (mm = 1mm/) 1 2 index div ConcatenateToMark =
mark (Actual_XMin = ) Actual_XMin (;  Actual_XMax = ) Actual_XMax (;  Actual_YMin = ) Actual_YMin (;  Actual_YMax = ) Actual_YMax ConcatenateToMark =

false  % Testing
{
	gsave  TileMatrix setmatrix
	Actual_XMin Actual_YMin moveto
	Actual_XMin Actual_YMax lineto
	Actual_XMax Actual_YMax lineto
	Actual_XMax Actual_YMin lineto
	closepath  PaperMatrix setmatrix  18 setlinewidth  0.8 setgray  stroke
	grestore
} if   % Testing


/PaintPath
{
	6 dict begin
	/LengthsGoingOut exch def  /PathId exch def  /YMax exch def  /XMax exch def  /YMin exch def  /XMin exch def
	XMax Actual_XMin ge  XMin Actual_XMax le  YMax Actual_YMin ge  YMin Actual_YMax le  and and and
	{
		LengthsGoingOut length 1 sub  -1  0
		{
			dup  LengthsGoingOut exch get //LongestPathToBeFilled le
			{
				1 add  LengthsGoingOut exch  0 exch  getinterval
				/LengthsGoingOut exch def  exit
			} {pop} ifelse
		} for

		//PaperMatrix setmatrix
		1 {
			LengthsGoingOut 0 get  //LongestPathToBeFilled  gt {exit} if
			LengthsGoingOut length 2 mod 0 eq       {gsave 0 0 0 0 setcmykcolor fill grestore exit} if
			% Because of odd-even rules, colours never touch +-2 that are strictly longer than 5. All other pairs can neighbour.
			%                                  Cyan Mgnt Ylw Blk
			LengthsGoingOut 0 get   5 eq {gsave 1    0.6  0  0.4  setcmykcolor fill grestore exit} if  % Dark blue
			LengthsGoingOut 0 get  15 eq {gsave 0    1    1  0.3  setcmykcolor fill grestore exit} if  % Dark red
			LengthsGoingOut 0 get  25 eq {gsave 1    0    1  0    setcmykcolor fill grestore exit} if  % Green
			LengthsGoingOut 0 get  55 eq {gsave 0    0.2  1  0    setcmykcolor fill grestore exit} if  % Yellow-gold
			LengthsGoingOut 0 get 105 eq {gsave 0.7  0    0  0    setcmykcolor fill grestore exit} if  % Light cyan
			LengthsGoingOut 0 get 215 eq {gsave 0    0.1  0  0.3  setcmykcolor fill grestore exit} if  % Grey-grey-red
			% This list needs to go as far as LongestPathToBeFilled ==> bigger LongestPathToBeFilled can require more colours here.
		} repeat  % 1, as exit'able.
		StrokeMulti
	} {newpath} ifelse  % In box
	end
} bind def  % /PaintPath




//TileMatrix setmatrix
0.5 1.538841769 moveto  0 0 R 72 180 arc   -2.736067977 1.538841769 moveto  -2.236067977 3.077683537 R 252 360 arc
-0.618033989 -3.077683537 moveto  -2.236067977 -3.077683537 R 0 108 arc   -1.618033989 0 moveto  0 0 R 180 288 arc
0.5 1.538841769 moveto  1 3.077683537 R -108 -72 arc   1.5 -1.538841769 moveto  1 -3.077683537 R 72 108 arc
PaperMatrix setmatrix  StrokeMulti

showpage

(\n\n) =
count              (      = count: this really should be 0\n)   dup 0  4 -1 roll  6 string cvs  putinterval
countdictstack     (      = countdictstack: this should be 3\n) dup 0  4 -1 roll  6 string cvs  putinterval  Concatenate =
count 0 gt {(+pstack) = pstack (-pstack) =} if

{countdictstack 3 gt {8 {() =} repeat currentdict {exch == =} forall end} {exit} ifelse} bind loop  % Final debugging
